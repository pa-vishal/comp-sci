<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Common Recursive Patterns</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <header>
        <h1>Mastering Recursion</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="mindset.html">The Mindset</a>
            <a href="analysis.html">Analysis</a>
            <a href="patterns.html" class="active">Common Patterns</a>
        </nav>
    </header>
    <main>
        <section class="card">
            <h2>Applying The Mastery: Common Patterns</h2>
            <p>Once you understand the fundamentals, you can start recognizing common recursive patterns in problems.</p>
        </section>

        <section class="card">
            <h3>Pattern 1: Tree Traversal / DFS</h3>
            <p>Recursion is the native language of trees. The pattern is always: process the current node, then recurse on its children.</p>
<pre><code class="language-python"><span class="keyword">def</span> <span class="function-name">traverse</span>(node):
    <span class="keyword">if</span> node <span class="keyword">is</span> None: <span class="comment"># Base Case</span>
        <span class="keyword">return</span>

    <span class="comment"># "Work" can be done here (Pre-order)...</span>
    process(node.value) 
    traverse(node.left)
    traverse(node.right)
    <span class="comment"># ...or here (In-order), or after the calls (Post-order).</span></code></pre>
        </section>

        <section class="card">
            <h3>Pattern 2: Backtracking ("Choose, Explore, Unchoose")</h3>
            <p>Used for finding all possible solutions (e.g., permutations, Sudoku). You explore one path of choices, and critically, you undo your choice to explore other paths.</p>
<pre><code class="language-python"><span class="keyword">def</span> <span class="function-name">find_solutions</span>(current_state):
    <span class="keyword">if</span> is_solution(current_state):
        add_solution(current_state)
        <span class="keyword">return</span>

    <span class="keyword">for</span> choice <span class="keyword">in</span> get_choices(current_state):
        <span class="comment"># 1. Choose</span>
        make_choice(current_state, choice)

        <span class="comment"># 2. Explore (Leap of Faith)</span>
        find_solutions(current_state)

        <span class="comment"># 3. Unchoose (CRITICAL for exploring other paths)</span>
        unmake_choice(current_state, choice)</code></pre>
        </section>

        <section class="card">
            <h3>Pattern 3: Dynamic Programming (Recursion + Memoization)</h3>
            <p>Use this when your recursion tree has <strong>overlapping subproblems</strong>. It's just smart recursion.</p>
            <p>1. Write the plain recursive solution. 2. Add a cache/memo. 3. Before computing, check the cache. 4. After computing, store the result in the cache.</p>
<pre><code class="language-python">memo = {}
<span class="keyword">def</span> <span class="function-name">fib_memo</span>(n):
    <span class="keyword">if</span> n <= 1: <span class="keyword">return</span> n
    
    <span class="comment"># Before computing, check the cache</span>
    <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]

    <span class="comment"># If not in cache, compute it</span>
    result = fib_memo(n-1) + fib_memo(n-2)

    <span class="comment"># Store it before returning</span>
    memo[n] = result
    <span class="keyword">return</span> result</code></pre>
        </section>

    </main>
    <footer>
        <p>&copy; 2023 Your Name Here. A guide for becoming an expert.</p>
    </footer>
</body>
</html>